#!/usr/bin/bash

# Init variables
search=''
replace=''
dir=''
insensitive=0
rg_opts_input=''

# ANSI escape sequences for coloring the output
GREEN='\033[0;92m'  # Green color
NC='\033[0m'        # No color
# Double escaped for usage in sed
SED_GREEN='\\033[0;32m'
RED='\\033[0;91m'
SED_NC='\\033[0m'
STRIKE='\\033[9m'    # Strikethrough effect

print_usage() {
        echo "Usage: snr [Options] search_expression replace_expression [path]"
        echo "-p option expects a path to be specified for recursive search as last argument"
        echo "-i for case-insensitive search"
        echo "-o for rg options, eg. snr -po -. search_term replace_with ./ (to search hidden files too)"
        echo "Without -p snr reads from SdtIn"
        echo "Search/Replace using regex; spaces and other special characters should be in quotes \" \""
        exit 0
}

while getopts 'ipo:h' flag; do
    case "${flag}" in
        i) insensitive=1 ;;
        p) dir="${!#}" ;;
        h) print_usage ;;
        o) rg_opts_input="${OPTARG}" ;;
        *) print_usage
           exit 1 ;;
    esac
done


# Check if the first argument starts with a hyphen (-) or double hyphen (--).
if [[ "$1" != -* ]]; then
    search="$1"
    replace="$2"
elif [[ "$1" =~ -.*[o] ]]; then
    search="$3"
    replace="$4"
else
    search="$2"
    replace="$3"
fi

printf "$search $replace\n"

# If a directory is provided with -p, use ripgrep (rg) to search for files containing the search term
if [[ -n "$dir" ]]; then
    # Set options for rg to perform the search for matching files

    rg_opts="-l $rg_opts_input"
    [[ "$insensitive" == 1 ]] && rg_opts="-i $rg_opts"
    # Store the list of file paths matching the search term in the specified directory
    readarray -t paths < <(rg $rg_opts "$search" "$dir")
else
    # Otherwise, read from stdin and store paths in an array
    readarray -t paths
fi

# Iterate over the array of file paths
for path in "${paths[@]}"; do
    # Convert relative path to absolute path using realpath
    abs_path=$(realpath "$path")

    echo "---------------------------------------------------------------------------------------------------"
    printf "${GREEN}$abs_path${NC}:\n"
    
    # sed command to perform the replacement: Add -I option for case-insensitive if needed
    sed_opts="gp"
    [[ "$insensitive" == 1 ]] && sed_opts="I $sed_opts"

    # Use echo -e to have colors; awk for line numbers; simulated replacement with sed
    echo -e "$(awk '{print NR ": " $0}' $path | sed -rn "s/$search/$RED$STRIKE&$SED_NC $SED_GREEN$replace$SED_NC/$sed_opts")"
    
    echo "---------------------------------------------------------------------------------------------------"
    
    # Prompt the user for input on whether to replace all occurrences in the file
    echo -n "Replace all in $path? y(es), n(o): " 
    read -n 1 input </dev/tty

    if [[ "$input" =~ ^[yY] ]]; then
        # Pattern Substitution to remove the p option
        sed_opts="${sed_opts//p/}"

        # Perform the Substitution in place
        sed -ri "s/$search/$replace/$sed_opts" "$path"
    elif [[ "$input" =~ ^[nN] ]]; then
        # If the user selects no, skip to the next file
        printf "\n\n"
        continue
    else 
        # If the input is invalid, ask the user again
        echo 
        printf "Invalid input! Yy/Nn: \n"
        echo -n "Replace all in $path? y(es), n(o): " 
        read -n 1 input </dev/tty
    fi
    printf "\n\n"
done
