#!/usr/bin/bash

# Init variables
search=''
replace=''
dir=''
insensitive=0

print_usage() {
        echo "Usage: snr [Options] search_expression replace_expression [path]"
        echo "-p option expects a path to be specified for recursive search as last argument"
        echo "-i for case-insensitive search"
        echo "Without -p snr reads from SdtIn"
        echo "Search/Replace using regex; spaces and other special characters should be in quotes \" \""
        exit 0
}

while getopts 'iph' flag; do
    case "${flag}" in
        i) insensitive=1 ;;
        p) dir="$4" ;;
        h) print_usage ;;
        *) print_usage
           exit 1 ;;
    esac
done

# Check if the first argument starts with a hyphen (-) or double hyphen (--).
if [[ "$1" != -* ]]; then
    search="$1"
    replace="$2"
else
    search="$2"
    replace="$3"
fi

# ANSI escape sequences for coloring the output
GREEN='\033[0;32m'  # Green color
STRIKE='\033[9m'    # Strikethrough effect
NC='\033[0m'        # No color


# If a directory is provided with -p, use ripgrep (rg) to search for files containing the search term
if [[ -n "$dir" ]]; then
    # Set options for rg to perform the search for matching files
    rg_opts="-l -."
    [[ "$insensitive" == 1 ]] && rg_opts="-i $rg_opts"
    # Store the list of file paths matching the search term in the specified directory
    readarray -t paths < <(rg $rg_opts "$search" "$dir")
else
    # Otherwise, read from stdin and store paths in an array
    readarray -t paths
fi

# Iterate over the array of file paths
for path in "${paths[@]}"; do
    # Convert relative path to absolute path using realpath
    abs_path=$(realpath "$path")

    echo "---------------------------------------------------------------------------------------------------"
    printf "${GREEN}$abs_path${NC}:\n"
    
    # Set options for ripgrep: -n to display line numbers, --no-heading to suppress file headers,
    # --color=always to color matches, and -i for case-insensitive search if enabled
    rg_opts="-n --no-heading --color=always -."
    [[ "$insensitive" == 1 ]] && rg_opts="-i $rg_opts"

    # Run ripgrep on the file and use awk to highlight and replace matched terms
    rg $rg_opts "$search" "$abs_path" | awk -v search="$search" -v replace="$replace" \
    -v green="$GREEN" -v strike="$STRIKE" -v nc="$NC" '
    BEGIN { IGNORECASE = 1 }
    {
        # gsub replaces the search term with a strikethrough version followed by the replacement in green
        gsub(search, strike "&" nc " " green replace nc);
        print;
    }'
    
    echo "---------------------------------------------------------------------------------------------------"
    
    # Prompt the user for input on whether to replace all occurrences in the file
    echo -n "Replace all in $path? y(es), n(o): " 
    read -n 1 input </dev/tty

    if [[ "$input" =~ ^[yY] ]]; then
        # sed command to perform the replacement: Add -I option for case-insensitive if needed
        sed_opts="g"
        [[ "$insensitive" == 1 ]] && sed_opts="I $sed_opts"

        sed -i "s/$search/$replace/$sed_opts" "$path"
    elif [[ "$input" =~ ^[nN] ]]; then
        # If the user selects no, skip to the next file
        printf "\n\n"
        continue
    else 
        # If the input is invalid, ask the user again
        echo 
        printf "Invalid input! Yy/Nn: \n"
        echo -n "Replace all in $path? y(es), n(o): " 
        read -n 1 input </dev/tty
    fi
    printf "\n\n"
done
